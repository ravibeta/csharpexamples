# Code was forked from java SDK to generated C# classes rather than Java. 
# Refer to Java SDK for instructions on how to use this. Search for the same file name there.

import sys
import re

# change the line below to point to a spec file in Java SDK.
input = open(
             'specs\JobExportArgs__GET_search_jobs_export.argspec',
             'r')

output = sys.stdout


def read_line():
    """
    Returns the next line from the input, including the EOL sequence.
    Throws StopIteration on EOF.
    
    Skips comment lines automatically.
    """
    while True:
        line = next(input)
        if line.startswith('#'):
            continue
        return line

def fix_doc(string):
    match = re.search(r"(.*)<p>(.*)", string) 
    if match:
        string = match.group(1) + """
    /// <para>
    /// """ + match.group(2) + """
    /// </para>
"""
    match = re.search(r"(.*){@link #set(.*)}", string) 
    if match:
        string = match.group(1);
        string += '<see cref="' 
        string += match.group(2)
        string += '''"/>
'''
    return string;

def lowercase_first_letter(string):
    return string[0].lower() + string[1:]


output.write("""    /* BEGIN AUTOGENERATED CODE */
    
""")

ignore_duplicates = False
args_already_seen = set()
ignored_machine_names = set()

try:
    while True:
        machine_name = read_line()[:-1]
        if machine_name.startswith('!'):
            # Actually this is a directive. Process it.
            directive = machine_name
            if directive == '!SET ignore_duplicates 1':
                ignore_duplicates = True
            elif directive.startswith('!SUPPRESS '):
                machine_name = directive[len('!SUPPRESS '):]
                ignored_machine_names.add(machine_name)
            else:
                sys.exit("Unknown directive: %s" % directive)
            continue
        java_name = read_line()[:-1]
        type = read_line()[:-1]
        
        description_lines = []
        reading_description = True
        code_lines = None
        while True:
            line = read_line()
            if line.startswith('!CODE'):
                code_lines = []
                reading_description = False
                continue
            if line.startswith('='):
                break
            
            if reading_description:
                description_lines.append(line)
            else:
                code_lines.append(line)
        
        if not java_name[0].isupper():
            sys.exit("Expected first letter to be uppercase: %s" % java_name)
        java_name_lower = lowercase_first_letter(java_name)
        
        # Generate the setter code
        if code_lines is not None:
            # Custom code for this setter
            code = ''.join(code_lines)[:-1];
        else:
            # Standard code for this setter, depending on its parameter type
            code = """        set { this["%s"] = value; }""" % (machine_name)

            # Convert Java type to C# equivalent
            if type == 'boolean':
                type = 'bool'
            if type == 'OutputMode' or type == 'TruncationMode' or type == 'SearchMode':
                type += 'Enum'
                code = """        set { this["%s"] = value.GetSplunkEnumValue(); }""" % (machine_name)
            if type == 'String':
                type = 'string'
            if '[]' in type or type == 'Date':
                if type == 'String[]-MULTIPLE':
                    type = 'string[]'
                elif type == 'String[]-CSV':
                    type = 'string[]'
                    code = """                // string[] were simply passed thru, it would be encoded as 
                // as Splunk REST API multi value parameter. 
                // Instead we want a comma separated string.
                this["%s"] = value.ToCsv();""" % (java_name_lower, java_name_lower, machine_name)
                else:
                    sys.exit("Don't know how to encode an array of type: %s" % type);
        
        # Split description_lines -> {method_description_lines, param_description_lines}
        method_description_lines = []
        param_description_lines = []
        saw_description_separator = False
        for line in description_lines:
            if line.startswith('-'):
                saw_description_separator = True
                continue
            
            if not saw_description_separator:
                method_description_lines.append(line)
            else:
                param_description_lines.append(line)
        
        if not saw_description_separator:
            print ('WARNING: No separate method description found for ' +
                'argument %s. This is against convention.') % machine_name
            param_description_lines = method_description_lines
            method_description_lines = []
        
        # Format method_description_lines
        method_description_formatted = ''
        if method_description_lines != []:
            for line in method_description_lines:
                method_description_formatted += '    /// %s' % line
        
        # Fix java doc tags for C# XML Docs for method description.
        method_description_formatted = fix_doc(method_description_formatted)

        # Format param_description_lines
        param_description_formatted = ''
        for line in param_description_lines:
            param_description_formatted += '     *      %s' % line
          
        # Fix java doc tags for C# XML Docs for parameter description.
        param_description_formatted = fix_doc(param_description_formatted)

        cur_arg = (machine_name, type)
        if cur_arg in args_already_seen:
            if ignore_duplicates:
                continue
            else:
                sys.exit("Multiple definitions for argument: %s %s" % (
                    type, machine_name));
        else:
            args_already_seen.add(cur_arg)
        
        # Output the current argument
        if machine_name not in ignored_machine_names:
            output.write("""    /// <summary>
%s    /// </summary>
    public """ % (method_description_formatted))

            # "Count" is a Property on ICollection. "new" is needed to avoid conflicts.
            if machine_name == 'count':
                output.write('new ')
                
            output.write("""%s %s 
    {
%s
    }
    
""" % (type, java_name,
       code))
    
except StopIteration:
    # Done!
    pass

output.write("""    /* END AUTOGENERATED CODE */
""")
pass